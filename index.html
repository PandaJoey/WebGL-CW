<!DOCTYPE html>
<html lang="en">
<head>
    <title>WebGL Coursework</title>
    <meta charset="utf-8">

    <script type="text/javascript" src="lib/glMatrix.js"></script>
    <script type="text/javascript" src="lib/webgl-utils.js"></script>
    <script type="text/javascript" src="lib/webgl-debug.js"></script>

    <!-- Vertex shader -->
    <script id="shader-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoordinates;


	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform mat3 uNMatrix;

	varying vec2 vTextureCoordinates;
	varying vec3 vNormalEye;
	varying vec3 vPositionEye;
	varying vec4 vColor;


	void main() {
		vec4 vertexPositionEye4 = uMVMatrix * vec4(aVertexPosition, 1.0);
		vPositionEye = vertexPositionEye4.xyz / vertexPositionEye4.w;

		vNormalEye = normalize(uNMatrix * aVertexNormal);

		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		vTextureCoordinates = aTextureCoordinates;

	}


    </script>

    <!-- Fragment shader -->
    <script id="shader-fs" type="x-shader/x-fragment">
	precision mediump float;

	varying vec2 vTextureCoordinates;
	varying vec3 vNormalEye;
	varying vec3 vPositionEye;


	uniform vec3 uLightPosition;
	uniform vec3 uAmbientLightColor;
	uniform vec3 uDiffuseLightColor;
	uniform vec3 uSpecularLightColor;
	uniform sampler2D uSampler;

	const float shininess = 32.0;

	void main() {

		vec3 vectorToLightSource = normalize(uLightPosition - vPositionEye);

		float diffuseLightWeighting = max(dot(vNormalEye, vectorToLightSource), 0.0);

		vec3 reflectionVector = normalize(reflect(-vectorToLightSource, vNormalEye));

		vec3 viewVectorEye = -normalize(vPositionEye);

		float rdotv = max(dot(reflectionVector, viewVectorEye), 0.0);
		float specularLightWeighting = pow(rdotv, shininess);

		vec3 lightWeighting = uAmbientLightColor +
							  uDiffuseLightColor * diffuseLightWeighting +
							  uSpecularLightColor * specularLightWeighting;

		vec4 texelColor = texture2D(uSampler, vTextureCoordinates);

		gl_FragColor = vec4(lightWeighting.rgb * texelColor.rgb, texelColor.a);
	}


    </script>

    <!-- The JavaScript for the WebGl program -->
    <script type="text/javascript">
        /**
         * Globals used throughout the project
         */
        var gl;							// The webgl object
        var canvas;
        var pwgl;						// Global object containing all program's internal vars and properties
        var drag = 0;			        // used to calculate mouse down

        // Mouse positions at mouse down, used for the drag calculations
        var lastMouseX = 0;
        var lastMouseY = 0;
        // Zoom and movement offsets
        var transX = 0;
        var transY = 0;
        var transZ = 0;
        // Total zoom distance
        var totalZ = 20;
        // Rotation offsets
        var xRotation = 0;
        var yRotation = 0;


        pwgl = {
            sphere: {					// Object for sphere model
                angle: 0.0
            },
            satellite: {				// Object for satellite model
                x: 0.0,					// Initial positioning of satellite
                y: 0.0,
                z: 0.0,
                angle: 0,
                circleRadius: 7.0,		// Initial radius of satellite's orbit
                orbitSpeed: 4000		// Initial orbital speed
            },


            texture: {   				// Object for texture data
                ongoingImageLoads: []	// Array to hold list of images while loading
            },

            animation: {
                startTime: undefined
            },

            shader: {                   // Object for holding shader data

            },
            interaction: {				// Object for holding mouse & keyboard interactions
                listOfPressedKeys: []	// Array of keys that have been pressed
            }
        };

        /**
         * Creates WebGL context from canvas element
         * @param  canvas Canvas object
         * @return {Object} WebGL context
         */
        function createGLContext(canvas) {
            var names = ['webgl', 'experimental-webgl'];
            var context = null;


            for (var i = 0; i < names.length; i++) {
                try {
                    context = canvas.getContext(names[i]);
                }
                catch (e) {
                }

                if (context)
                    break;
            }

            if (context) {
                context.viewportWidth = canvas.width;
                context.viewportHeight = canvas.height;
            }
            else {
                alert("Could not initiate WebGL, Please refresh");
            }

            return context;
        }

        /**
         * Loads vertex & fragment shaders from DOM
         * @param  {String} id Id of shader element
         * @return {Object}    Shader object
         */
        function loadShaderFromDOM(id) {
            var shaderScript = document.getElementById(id);

            if (!shaderScript)
                return null;

            var shaderSource = '';
            var currentChild = shaderScript.firstChild;

            while (currentChild) {
                if (currentChild.nodeType === 3) { // Text node
                    shaderSource += currentChild.textContent;
                }
                currentChild = currentChild.nextSibling;
            }

            var shader;
            if (shaderScript.type === 'x-shader/x-fragment') {
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            }
            else if (shaderScript.type === 'x-shader/x-vertex') {
                shader = gl.createShader(gl.VERTEX_SHADER);
            }
            else {
                return null;
            }

            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(shader));
                return null;
            }

            return shader;
        }

        /**
         * Initialises WebGL Shaders
         */
        function setupShaders() {
            var vertexShader = loadShaderFromDOM('shader-vs');
            var fragmentShader = loadShaderFromDOM('shader-fs');
            var shaderProgram = gl.createProgram();

            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);

            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Could not initialise shaders, please refresh');
            }

            gl.useProgram(shaderProgram);

            // Caches positions of attributes & uniforms in shaders
            pwgl.shader.vertexPositionAttributeLoc = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
            pwgl.shader.vertexTextureAttributeLoc = gl.getAttribLocation(shaderProgram, 'aTextureCoordinates');
            pwgl.shader.vertexNormalAttributeLoc = gl.getAttribLocation(shaderProgram, 'aVertexNormal');

            pwgl.shader.uniformMVMatrixLoc = gl.getUniformLocation(shaderProgram, 'uMVMatrix');
            pwgl.shader.uniformProjMatrixLoc = gl.getUniformLocation(shaderProgram, 'uPMatrix');
            pwgl.shader.uniformNormalMatrixLoc = gl.getUniformLocation(shaderProgram, 'uNMatrix');

            pwgl.shader.uniformSamplerLoc = gl.getUniformLocation(shaderProgram, 'uSampler');

            pwgl.shader.uniformLightPositionLoc = gl.getUniformLocation(shaderProgram, 'uLightPosition');
            pwgl.shader.uniformAmbientLightColorLoc = gl.getUniformLocation(shaderProgram, 'uAmbientLightColor');
            pwgl.shader.uniformDiffuseLightColorLoc = gl.getUniformLocation(shaderProgram, 'uDiffuseLightColor');
            pwgl.shader.uniformSpecularLightColorLoc = gl.getUniformLocation(shaderProgram, 'uSpecularLightColor');

            gl.enableVertexAttribArray(pwgl.shader.vertexPositionAttributeLoc);
            gl.enableVertexAttribArray(pwgl.shader.vertexNormalAttributeLoc);
            gl.enableVertexAttribArray(pwgl.shader.vertexTextureAttributeLoc);

            // Create ModelView & Projection matrices
            pwgl.modelViewMatrix = mat4.create();
            pwgl.projectionMatrix = mat4.create();
            pwgl.modelViewMatrixStack = [];
        }

        /**
         * Initialises the model buffers
         */
        function setupBuffers() {
            setupSatelliteBuffers();
            setupSphereBuffers();


        }

        /**
         * Initialises model buffers for the satellite
         */
        function setupSatelliteBuffers() {


            var satelliteTextureCoordinateData = [
                // Front face
                0.5, 0.5,
                0.0, 0.5,
                0.0, 0.0,
                0.5, 0.0,

                // Back face
                0.0, 0.5,
                0.0, 0.0,
                0.5, 0.0,
                0.5, 0.5,

                // Top face
                0.5, 0.0,
                0.5, 0.5,
                0.0, 0.5,
                0.0, 0.0,

                // Bottom face
                0.0, 0.0,
                0.5, 0.0,
                0.5, 0.5,
                0.0, 0.5,

                // Right face
                0.0, 0.5,
                0.0, 0.0,
                0.5, 0.0,
                0.5, 0.5,

                // Left face - faces the earth, must use left half of texture (grey)
                1.0, 1.0,
                0.5, 1.0,
                0.5, 0.5,
                1.0, 0.5
            ];

            var satellitePositionData = [
                // Front face
                -2.0, -2.0, 2.0,
                2.0, -2.0, 2.0,
                2.0, 2.0, 2.0,
                -2.0, 2.0, 2.0,

                // Back face
                -2.0, -2.0, -2.0,
                -2.0, 2.0, -2.0,
                2.0, 2.0, -2.0,
                2.0, -2.0, -2.0,

                // Top face
                -2.0, 2.0, -2.0,
                -2.0, 2.0, 2.0,
                2.0, 2.0, 2.0,
                2.0, 2.0, -2.0,

                // Bottom face
                -2.0, -2.0, -2.0,
                2.0, -2.0, -2.0,
                2.0, -2.0, 2.0,
                -2.0, -2.0, 2.0,

                // Right face
                2.0, -2.0, -2.0,
                2.0, 2.0, -2.0,
                2.0, 2.0, 2.0,
                2.0, -2.0, 2.0,

                // Left face
                -2.0, -2.0, -2.0,
                -2.0, -2.0, 2.0,
                -2.0, 2.0, 2.0,
                -2.0, 2.0, -2.0
            ];

            var satelliteNormalData = [
                // Front face
                0.0, 0.0, 1.0,
                0.0, 0.0, 1.0,
                0.0, 0.0, 1.0,
                0.0, 0.0, 1.0,

                // Back face
                0.0, 0.0, -1.0,
                0.0, 0.0, -1.0,
                0.0, 0.0, -1.0,
                0.0, 0.0, -1.0,

                // Top face
                0.0, 1.0, 0.0,
                0.0, 1.0, 0.0,
                0.0, 1.0, 0.0,
                0.0, 1.0, 0.0,

                // Bottom face
                0.0, -1.0, 0.0,
                0.0, -1.0, 0.0,
                0.0, -1.0, 0.0,
                0.0, -1.0, 0.0,

                // Right face
                1.0, 0.0, 0.0,
                1.0, 0.0, 0.0,
                1.0, 0.0, 0.0,
                1.0, 0.0, 0.0,

                // Left face
                -1.0, 0.0, 0.0,
                -1.0, 0.0, 0.0,
                -1.0, 0.0, 0.0,
                -1.0, 0.0, 0.0
            ];

            var satelliteIndexData = [
                0, 1, 2, 0, 2, 3, 	// Front face
                4, 5, 6, 4, 6, 7, 	// Back face
                8, 9, 10, 8, 10, 11,	// Top face
                12, 13, 14, 12, 14, 15,	// Bottom face
                16, 17, 18, 16, 18, 19,	// Right face
                20, 21, 22, 20, 22, 23 	// Left face
            ];

            // Creates texture buffer & loads texture data
            pwgl.satellite.vertexTextureCoordinateBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.satellite.vertexTextureCoordinateBuffer);

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(satelliteTextureCoordinateData), gl.STATIC_DRAW);

            pwgl.satellite.vertexTexelCoordinatesBufferItemSize = 2;
            pwgl.satellite.vertexTexelCoordinatesBufferNumItems = satelliteTextureCoordinateData.length / 2;

            // Creates position buffer & loads position data
            pwgl.satellite.vertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.satellite.vertexPositionBuffer);

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(satellitePositionData), gl.STATIC_DRAW);

            pwgl.satellite.vertexPositionBufferItemSize = 3;
            pwgl.satellite.vertexPositionBufferNumItems = satellitePositionData.length / 3;

            // Create normal buffer & loads normal data
            pwgl.satellite.vertexNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.satellite.vertexNormalBuffer);

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(satelliteNormalData), gl.STATIC_DRAW);

            pwgl.satellite.vertexNormalabufferItemSize = 3;
            pwgl.satellite.vertexNormalabufferNumItems = satelliteNormalData.length / 3;

            // Creates index buffer & loads index data
            pwgl.satellite.vertexIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pwgl.satellite.vertexIndexBuffer);

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(satelliteIndexData), gl.STATIC_DRAW);

            pwgl.satellite.vertexIndexBufferItemSize = 1;
            pwgl.satellite.vertexIndexBufferNumItems = satelliteIndexData.length;
        }


        /**
         * Initialises the model buffers for the sphere object
         */
        function setupSphereBuffers() {
            var sphereNormalData = [];
            var sphereTextureCoordData = [];
            var spherePositionData = [];
            var sphereindexData = [];

            var latitude = 30; // Number of latitude bands
            var longitude = 30; // Number of longitude bands
            var radius = 5;  // Radius of sphere

            var theta;
            var sinTheta;
            var cosTheta;
            var phi;
            var sinPhi;
            var cosPhi;
            var x;
            var y;
            var z;
            var u;
            var v;
            var v1;
            var v2;

            for (var i = 0; i <= latitude; i++) {
                theta = i * Math.PI / latitude;
                sinTheta = Math.sin(theta);
                cosTheta = Math.cos(theta);

                for (var j = 0; j <= longitude; j++) {
                    phi = j * 2 * Math.PI / longitude;
                    sinPhi = Math.sin(phi);
                    cosPhi = Math.cos(phi);

                    x = cosPhi * sinTheta;
                    y = cosTheta;
                    z = sinPhi * sinTheta;

                    u = 1 - (j / longitude);
                    v = 1 - (i / latitude);

                    sphereNormalData.push(x);
                    sphereNormalData.push(y);
                    sphereNormalData.push(z);

                    sphereTextureCoordData.push(u);
                    sphereTextureCoordData.push(v);

                    spherePositionData.push(radius * x);
                    spherePositionData.push(radius * y);
                    spherePositionData.push(radius * z);
                }
            }

            for (var i = 0; i < latitude; i++) {
                for (var j = 0; j < longitude; j++) {
                    v1 = (i * (longitude + 1)) + j;
                    v2 = v1 + longitude + 1;

                    // Indices of first triangle
                    sphereindexData.push(v1);
                    sphereindexData.push(v2);
                    sphereindexData.push(v1 + 1);

                    // Indices of second triangle
                    sphereindexData.push(v2);
                    sphereindexData.push(v2 + 1);
                    sphereindexData.push(v1 + 1);
                }
            }

            // Create normal buffer & loads normal data
            pwgl.sphere.vertexNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.sphere.vertexNormalBuffer);

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereNormalData), gl.STATIC_DRAW);

            pwgl.sphere.vertexNormalabufferItemSize = 3;
            pwgl.sphere.vertexNormalabufferNumItems = sphereNormalData.length / 3;

            // Creates texture buffer & loads texture data
            pwgl.sphere.vertexTextureCoordinateBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.sphere.vertexTextureCoordinateBuffer);

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereTextureCoordData), gl.STATIC_DRAW);

            pwgl.sphere.vertexTexelCoordinatesBufferItemSize = 2;
            pwgl.sphere.vertexTexelCoordinatesBufferNumItems = sphereTextureCoordData.length / 2;

            // Creates position buffer & loads position data
            pwgl.sphere.vertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.sphere.vertexPositionBuffer);

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(spherePositionData), gl.STATIC_DRAW);

            pwgl.sphere.vertexPositionBufferItemSize = 3;
            pwgl.sphere.vertexPositionBufferNumItems = spherePositionData.length / 3;

            // Creates index buffer & loads index data
            pwgl.sphere.vertexIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pwgl.sphere.vertexIndexBuffer);

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sphereindexData), gl.STATIC_DRAW);

            pwgl.sphere.vertexIndexBufferItemSize = 1;
            pwgl.sphere.vertexIndexBufferNumItems = sphereindexData.length;
        }

        /**
         * Initialises textures
         */
        function setupTextures() {
            // Earth texture
            pwgl.texture.earthTexture = gl.createTexture();
            loadImageForTexture('assets/earth.jpg', pwgl.texture.earthTexture);

            pwgl.texture.satelliteTexture = gl.createTexture();
            loadImageForTexture('assets/satellite.png', pwgl.texture.satelliteTexture);

            pwgl.texture.rodTexture = gl.createTexture();
            loadImageForTexture('assets/rod.jpg', pwgl.texture.rodTexture);

            pwgl.texture.panelTexture = gl.createTexture();
            loadImageForTexture('assets/satellitepanel.jpg', pwgl.texture.panelTexture);

        }

        /**
         * Creates Image DOM element & sets up callback to load as texture
         * @param  {String} url     Url to image
         * @param  {Object} texture Target texture object
         */
        function loadImageForTexture(url, texture) {
            var image = new Image();

            // Sets up callback for when image has finished downloading
            image.onload = function () {
                // Removes current image out of ongoingImageLoads array
                pwgl.texture.ongoingImageLoads.splice(pwgl.texture.ongoingImageLoads.indexOf(image), 1);

                textureFinishedLoading(image, texture);
            };

            pwgl.texture.ongoingImageLoads.push(image);
            image.src = url;
        }

        /**
         * Binds image object to texture, and generates mipmap
         * @param  {DOM Object} image   Image DOM element
         * @param  {Object}     texture Target texture object
         */
        function textureFinishedLoading(image, texture) {
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // Flips image to use WebGL axis, instead of DOM axis
            gl.bindTexture(gl.TEXTURE_2D, texture);

            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); // Image loaded, texture area 0
            gl.generateMipmap(gl.TEXTURE_2D); // Generates mipmap levels

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);

            gl.bindTexture(gl.TEXTURE_2D, null);
        }

        /**
         * Initialises lighting
         */
        function setupLights() {
            gl.uniform3fv(pwgl.shader.uniformLightPositionLoc, [60.0, 60.0, 0.0]); // Directional lighting from above
            gl.uniform3fv(pwgl.shader.uniformAmbientLightColorLoc, [0.5, 0.5, 0.5]); // Low ambient lighting
            gl.uniform3fv(pwgl.shader.uniformDiffuseLightColorLoc, [1.0, 1.0, 1.0]); // High level of diffusion
            gl.uniform3fv(pwgl.shader.uniformSpecularLightColorLoc, [0.2, 0.2, 0.2]); // Low level of specular reflection
        }

        /**
         * Caches copy of ModelView matrix in buffer before transformation
         */
        function pushModelViewMatrix() {
            var cache = mat4.create(pwgl.modelViewMatrix);
            pwgl.modelViewMatrixStack.push(cache);
        }

        /**
         * Pops original ModelView matrix off buffer after transformation
         */
        function popModelViewMatrix() {
            if (pwgl.modelViewMatrixStack.length === 0) {
                throw 'Error - ModelView Stack empty';
            }
            pwgl.modelViewMatrix = pwgl.modelViewMatrixStack.pop();
        }

        /**
         * Uploads ModelView matrix to shader
         */
        function uploadModelViewMatrixToShader() {
            gl.uniformMatrix4fv(pwgl.shader.uniformMVMatrixLoc, false, pwgl.modelViewMatrix);
        }

        /**
         * Uploads Projection matrix to shader
         */
        function uploadProjectionMatrixToShader() {
            gl.uniformMatrix4fv(pwgl.shader.uniformProjMatrixLoc, false, pwgl.projectionMatrix);
        }

        /**
         * Creates Normal matrix and uploads to shader
         */
        function uploadNormalMatrixToShader() {
            var normalMatrix = mat3.create();
            mat4.toInverseMat3(pwgl.modelViewMatrix, normalMatrix);
            mat3.transpose(normalMatrix);

            gl.uniformMatrix3fv(pwgl.shader.uniformNormalMatrixLoc, false, normalMatrix);
        }

        /**
         * Draws satellite
         */
        function drawSatellite() {
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, pwgl.texture.satelliteTexture);

            // Bind position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.satellite.vertexPositionBuffer);
            gl.vertexAttribPointer(pwgl.shader.vertexPositionAttributeLoc, pwgl.satellite.vertexNormalabufferItemSize, gl.FLOAT, false, 0, 0);

            // Bind normal buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.satellite.vertexNormalBuffer);
            gl.vertexAttribPointer(pwgl.shader.vertexNormalAttributeLoc, pwgl.satellite.vertexNormalabufferItemSize, gl.FLOAT, false, 0, 0);

            // Bind texture buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.satellite.vertexTextureCoordinateBuffer);
            gl.vertexAttribPointer(pwgl.shader.vertexTextureAttributeLoc, pwgl.satellite.vertexTexelCoordinatesBufferItemSize, gl.FLOAT, false, 0, 0);

            // Bind index buffer
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pwgl.satellite.vertexIndexBuffer);

            // Draw shape
            gl.drawElements(gl.TRIANGLES, pwgl.satellite.vertexIndexBufferNumItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawSatelliteRods() {

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, pwgl.texture.satelliteTexture);

            // Bind position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.satellite.vertexPositionBuffer);
            gl.vertexAttribPointer(pwgl.shader.vertexPositionAttributeLoc, pwgl.satellite.vertexPositionBufferItemSize, gl.FLOAT, false, 0, 0);

            // Bind normal buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.satellite.vertexNormalBuffer);
            gl.vertexAttribPointer(pwgl.shader.vertexNormalAttributeLoc, pwgl.satellite.vertexNormalabufferItemSize, gl.FLOAT, false, 0, 0);

            // Bind texture buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.satellite.vertexTextureCoordinateBuffer);
            gl.vertexAttribPointer(pwgl.shader.vertexTextureAttributeLoc, pwgl.satellite.vertexTexelCoordinatesBufferItemSize, gl.FLOAT, false, 0, 0);

            // Bind index buffer
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pwgl.satellite.vertexIndexBuffer);

            // Draw shape
            gl.drawElements(gl.TRIANGLES, pwgl.satellite.vertexIndexBufferNumItems, gl.UNSIGNED_SHORT, 0);

        }


        function drawSatellitePanels() {


            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, pwgl.texture.panelTexture);

            // Bind position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.satellite.vertexPositionBuffer);
            gl.vertexAttribPointer(pwgl.shader.vertexPositionAttributeLoc, pwgl.satellite.vertexPositionBufferItemSize, gl.FLOAT, false, 0, 0);

            // Bind normal buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.satellite.vertexNormalBuffer);
            gl.vertexAttribPointer(pwgl.shader.vertexNormalAttributeLoc, pwgl.satellite.vertexNormalabufferItemSize, gl.FLOAT, false, 0, 0);

            // Bind texture buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.satellite.vertexTextureCoordinateBuffer);
            gl.vertexAttribPointer(pwgl.shader.vertexTextureAttributeLoc, pwgl.satellite.vertexTexelCoordinatesBufferItemSize, gl.FLOAT, false, 0, 0);

            // Bind index buffer
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pwgl.satellite.vertexIndexBuffer);

            // Draw shape
            gl.drawElements(gl.TRIANGLES, pwgl.satellite.vertexIndexBufferNumItems, gl.UNSIGNED_SHORT, 0);


        }

        /**
         * Draws the sphere
         */
        function drawSphere() {
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, pwgl.texture.earthTexture);

            // Bind position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.sphere.vertexPositionBuffer);
            gl.vertexAttribPointer(pwgl.shader.vertexPositionAttributeLoc, pwgl.sphere.vertexPositionBufferItemSize, gl.FLOAT, false, 0, 0);

            // Bind normal buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.sphere.vertexNormalBuffer);
            gl.vertexAttribPointer(pwgl.shader.vertexNormalAttributeLoc, pwgl.sphere.vertexNormalabufferItemSize, gl.FLOAT, false, 0, 0);

            // Bind texture buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.sphere.vertexTextureCoordinateBuffer);
            gl.vertexAttribPointer(pwgl.shader.vertexTextureAttributeLoc, pwgl.sphere.vertexTexelCoordinatesBufferItemSize, gl.FLOAT, false, 0, 0);

            // Bind index buffer
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pwgl.sphere.vertexIndexBuffer);

            // Draw shape
            gl.drawElements(gl.TRIANGLES, pwgl.sphere.vertexIndexBufferNumItems, gl.UNSIGNED_SHORT, 0);
        }

        /**
         * Creates animation loop & draws shapes on canvas
         * @param  {Int} currentTime Time in miliseconds how often redraws occur.
         */
        function draw(currentTime) {
            // Creates animation loop
            pwgl.requestId = requestAnimFrame(draw);

            if (pwgl.animation.startTime === undefined)
                pwgl.animation.startTime = currentTime;

            // Keys keyboard for currently pressed keys
            checkPressedDownKeys();

            // Translate projection to zoom in/out controls
            mat4.translate(pwgl.projectionMatrix, [transX, transY, transZ], pwgl.projectionMatrix);

            // Rotate ModelView for rotation controls
            mat4.rotateX(pwgl.modelViewMatrix, xRotation / 100, pwgl.modelViewMatrix);
            mat4.rotateY(pwgl.modelViewMatrix, yRotation / 100, pwgl.modelViewMatrix);

            // Reset zoom/rotation values
            yRotation = xRotation = transX = transY = transZ = 0;

            uploadProjectionMatrixToShader();
            uploadModelViewMatrixToShader();
            uploadNormalMatrixToShader();

            // Clears canvas of previously drawn shapes
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.uniform1i(pwgl.shader.uniformSamplerLoc, 0);

            // Draw satellite
            pushModelViewMatrix();
            // Calculates satellite's x & z positions for orbit
            pwgl.satellite.angle = (currentTime - pwgl.animation.startTime) / pwgl.satellite.orbitSpeed * 2 * Math.PI % (2 * Math.PI);
            pwgl.satellite.x = Math.cos(pwgl.satellite.angle) * pwgl.satellite.circleRadius;
            pwgl.satellite.z = Math.sin(pwgl.satellite.angle) * pwgl.satellite.circleRadius;
            // Translates satellite into orbit
            mat4.translate(pwgl.modelViewMatrix, [pwgl.satellite.x, pwgl.satellite.y, pwgl.satellite.z], pwgl.modelViewMatrix);
            // Scales satellite to correct size
            mat4.scale(pwgl.modelViewMatrix, [0.2, 0.2, 0.2], pwgl.modelViewMatrix);
            // Rotates to face earth
            mat4.rotateY(pwgl.modelViewMatrix, -pwgl.satellite.angle, pwgl.modelViewMatrix);
            uploadModelViewMatrixToShader();
            uploadNormalMatrixToShader();
            drawSatellite();
            popModelViewMatrix();

            // Draw rod one
            pushModelViewMatrix();
            var xr = Math.cos(pwgl.satellite.angle) * (pwgl.satellite.circleRadius + 0.5);
            var zr = Math.sin(pwgl.satellite.angle) * (pwgl.satellite.circleRadius + 0.5);
            mat4.translate(pwgl.modelViewMatrix, [xr, pwgl.satellite.y, zr], pwgl.modelViewMatrix);
            mat4.rotateY(pwgl.modelViewMatrix, -pwgl.satellite.angle, pwgl.modelViewMatrix);
            mat4.scale(pwgl.modelViewMatrix, [0.02, 0.02, 0.05], pwgl.modelViewMatrix);
            uploadModelViewMatrixToShader();
            drawSatelliteRods();
            popModelViewMatrix();
            // draw rod two
            pushModelViewMatrix();
            xr = Math.cos(pwgl.satellite.angle) * (pwgl.satellite.circleRadius - 0.5);
            zr = Math.sin(pwgl.satellite.angle) * (pwgl.satellite.circleRadius - 0.5);
            mat4.translate(pwgl.modelViewMatrix, [xr, pwgl.satellite.y, zr], pwgl.modelViewMatrix);
            mat4.rotateY(pwgl.modelViewMatrix, -pwgl.satellite.angle, pwgl.modelViewMatrix);
            mat4.scale(pwgl.modelViewMatrix, [0.02, 0.02, 0.05], pwgl.modelViewMatrix);
            uploadModelViewMatrixToShader();
            drawSatelliteRods();
            popModelViewMatrix();

            // Draw panel one
            pushModelViewMatrix();
            xr = Math.cos(pwgl.satellite.angle) * (pwgl.satellite.circleRadius + 0.7);
            zr = Math.sin(pwgl.satellite.angle) * (pwgl.satellite.circleRadius + 0.7);
            mat4.translate(pwgl.modelViewMatrix, [xr, pwgl.satellite.y, zr], pwgl.modelViewMatrix);
            mat4.rotateY(pwgl.modelViewMatrix, -pwgl.satellite.angle, pwgl.modelViewMatrix);
            mat4.scale(pwgl.modelViewMatrix, [0.1, 0.2, 0.0], pwgl.modelViewMatrix);
            uploadModelViewMatrixToShader();
            drawSatellitePanels();
            popModelViewMatrix();

            // Draw panel two
            pushModelViewMatrix();
            xr = Math.cos(pwgl.satellite.angle) * (pwgl.satellite.circleRadius - 0.7);
            zr = Math.sin(pwgl.satellite.angle) * (pwgl.satellite.circleRadius - 0.7);
            mat4.translate(pwgl.modelViewMatrix, [xr, pwgl.satellite.y, zr], pwgl.modelViewMatrix);
            mat4.rotateY(pwgl.modelViewMatrix, -pwgl.satellite.angle, pwgl.modelViewMatrix);
            mat4.scale(pwgl.modelViewMatrix, [0.1, 0.2, 0.0], pwgl.modelViewMatrix);
            uploadModelViewMatrixToShader();
            drawSatellitePanels();
            popModelViewMatrix();

            // Draw sphere
            pushModelViewMatrix();
            pwgl.sphere.angle = (currentTime - pwgl.animation.startTime) / 24000 * 2 * Math.PI % (2 * Math.PI);
            mat4.rotateY(pwgl.modelViewMatrix, -pwgl.sphere.angle, pwgl.modelViewMatrix);
            uploadModelViewMatrixToShader();
            uploadNormalMatrixToShader();
            drawSphere();
            popModelViewMatrix();
        }

        /**
         * Initialises before draw
         */
        function init() {
            setupShaders();
            setupBuffers();
            setupTextures();
            setupLights();

            // Sets background colour to black
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);

            // Sets up camera
            mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pwgl.projectionMatrix);
            mat4.identity(pwgl.modelViewMatrix);
            mat4.lookAt([0, 0, 30], [0, 0, 0], [0, 1, 0], pwgl.modelViewMatrix); // Camera moved back from model, and looks at origin
        }

        /**
         * Creates event handlers and fires initialisation and draw function
         */
        function startup() {
            canvas = document.getElementById('myGLCanvas');
            canvas = WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas);

            // WebGL event handlers
            canvas.addEventListener('webglcontextlost', handleContextLost, false);
            canvas.addEventListener('webglcontextrestored', handleContextRestored, false);

            // Mouse event handlers
            canvas.addEventListener('mousedown', handleMouseDown, false);
            canvas.addEventListener('mouseup', handleMouseUp, false);
            canvas.addEventListener('mousemove', handleMouseMove, false);
            canvas.addEventListener('wheel', handleMouseWheel, false); // Many handlers for scroll, different browsers
            canvas.addEventListener('mousewheel', handleMouseWheel, false);
            canvas.addEventListener('DOMMouseScroll', handleMouseMove, false);

            // Keyboard event handlers
            document.addEventListener('keydown', handleKeyDown, false);
            document.addEventListener('keyup', handleKeyUp, false);

            gl = createGLContext(canvas);

            init();

            draw();
        }

        /**
         * Handles WebGL losing context from canvas and prevents textures from being loaded
         */
        function handleContextLost(e) {
            e.preventDefault();
            cancelRequestAnimFrame(pwgl.requestId);

            // Ignore all ongoing image loads by removing their onload handler
            for (var i = 0; i < pwgl.texture.ongoingImageLoads.length; i++) {
                pwgl.texture.ongoingImageLoads[i].onload = undefined;
            }
            pwgl.texture.ongoingImageLoads = [];
        }

        /**
         * Handles WebGL restoring context on canvas and sets up animation loop again
         */
        function handleContextRestored(e) {
            init();
            draw();
        }

        /**
         * Handles mousedown event and caches mouse position for drag distance calc
         */
        function handleMouseDown(e) {
            drag = 1;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        }

        /**
         * Handles mouseup event and cancels drag
         */
        function handleMouseUp(e) {
            drag = 0;
        }

        /**
         * Handles various scroll events and calculates zoom distance
         */
        function handleMouseWheel(e) {
            e.preventDefault();


            if (e.wheelDelta) {
                // Prevent zooming too far
                if (e.wheelDelta > 0) {
                    if (totalZ >= 35)
                        return;
                }
                else {
                    if (totalZ <= -55)
                        return;
                }
                transZ += e.wheelDelta / 120;
                totalZ += e.wheelDelta / 120;
            }

            // firefox fix
            else if (e.deltaY) {
                // Prevent zooming too far
                if (e.deltaY < 0) {
                    if (totalZ >= 35)
                        return;
                }
                else {
                    if (totalZ <= -55)
                        return;
                }
                transZ += -e.deltaY / 10;
                totalZ += -e.deltaY / 10;
            }

        }


        /**
         * Listens for mousemove and calculates drag distance if mouse was down during move
         */
        function handleMouseMove(e) {
            // If mouse wasn't down, exit
            if (drag === 0)
                return;
            if (e.shiftKey) {
                transX = (e.clientX - lastMouseX) / 10;
            }
            else if (e.altKey) {
                transY = -(e.clientY - lastMouseY) / 10;
            }
            else {
                yRotation = -lastMouseX + e.clientX;
                xRotation = -lastMouseY + e.clientY;
            }


            lastMouseX = e.clientX;
            lastMouseY = e.clientY;


        }


        /**
         * Handles keydown event and caches keycode
         */
        function handleKeyDown(e) {
            if (e.shiftKey || e.altKey || e.keyCode === 38 || e.keyCode === 40 || e.keyCode === 37 || e.keyCode === 39)
                e.preventDefault();

            pwgl.interaction.listOfPressedKeys[e.keyCode] = true;
        }

        /**
         * Handles keyup event and removes keycode from cache
         */
        function handleKeyUp(e) {
            if (e.shiftKey || e.altKey || e.keyCode === 38
                || e.keyCode === 40 || e.keyCode === 37 || e.keyCode === 39)
                e.preventDefault();

            pwgl.interaction.listOfPressedKeys[e.keyCode] = false;
        }

        /**
         * Tests which keys are currently pressed, and increases/decreases satellite orbit
         */
        function checkPressedDownKeys() {
            // Right arrow, increase radius of orbit
            if (pwgl.interaction.listOfPressedKeys[39]) {
                pwgl.satellite.circleRadius += 0.1;
            }

            // Left arrow, decrease radius of orbit
            if (pwgl.interaction.listOfPressedKeys[37]) {
                if (pwgl.satellite.circleRadius < 5.5)
                    return;

                pwgl.satellite.circleRadius -= 0.1;
            }

            // up Arrow, decrease orbit speed
            if (pwgl.interaction.listOfPressedKeys[38]) {
                pwgl.satellite.orbitSpeed += 10;
            }
            // down arrow, increase orbit speed
            if (pwgl.interaction.listOfPressedKeys[40]) {
                if (pwgl.satellite.orbitSpeed <= 0)
                    return;

                pwgl.satellite.orbitSpeed -= 10;
            }
        }

    </script>

    <style>
        #myGLCanvas {
            float: left;
            margin-right: 10px;
        }

        .noselect {
            -webkit-touch-callout: none; /* iOS Safari */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none;
        }

    </style>

</head>
<body onload="startup()">
<canvas id="myGLCanvas" width="750" height="750"></canvas>

<div id="id">
    <p class="noselect">Student Number: UP623013</p>
</div>

<div id="controls">
    <h4 class="noselect">Controls</h4>
    <p class="noselect">Click and drag to rotate the scene</p>
    <p class="noselect">Mouse wheel up zooms in and mouse wheel down zooms out</p>
    <p class="noselect">Hold shift + mouse drag to move left and right along the x-axis</p>
    <p class="noselect">Hold alt + mouse drag to move up and down along the y-axis</p>
    <p class="noselect">Up and down arrow keys increase and decrease the satellite orbit speed/p>
    <p class="noselect">Left and right arrow keys increase or decrease the satellite circular orbit</p>
</div>
</body>
</html>
